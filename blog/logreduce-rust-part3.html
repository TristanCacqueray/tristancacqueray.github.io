<!DOCTYPE html>
<!-- DoNotFormat -->
<!-- DoNotFormat -->




<!-- DoNotFormat -->
<!-- DoNotFormat -->

<html lang='en'>

<head>
  <meta charset='UTF-8' />
  <meta name='viewport' content='width=device-width, initial-scale=1' />
  <title>
    Introducing the BytesLines iterator – Tristan's Zettelkasten
  </title>
  
    
      <meta property='og:description' content='This post was initially published on the Software Factory blog: https://www.softwarefactory-project.io/introducing-the-byteslines-iterator.html' />
      <meta property='og:site_name' content="Tristan's Zettelkasten" />
      <meta property='og:image' content='https://midirus.com/' />
      <meta property='og:type' content='website' />
      <meta property='og:title' content='Introducing the BytesLines iterator' />
      
        <meta name='twitter:card' content='summary_large_image' />
      
    
    
      <base href='/' />
      <link href='/static/favicon.jpeg' rel='icon' />
    
    <!-- highlight.js -->
<link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/hybrid.min.css' />
<script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js'></script>
<!-- Include languages that Emanote itself uses -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/languages/haskell.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/languages/nix.min.js'></script>
<script>hljs.highlightAll();</script>



<script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/languages/lisp.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/languages/scheme.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/languages/glsl.min.js'></script>

<script src='/static/godiag.js'></script>
<style>
.kbd {
    display: inline-block;
    padding: 0.25rem;
    font: 11px mono;
    line-height: 10px;
    color: #1f2328;
    vertical-align: middle;
    background-color: rgb(246, 248, 250);
    border: solid 1px #1f232826;
    border-bottom-color: rgba(209, 217, 224, 0.7);
    border-radius: 6px;
    box-shadow: inset 0 -1px 0 #d1d9e0b3;
  }
}
code.baduk {
  background-color: white;
  color: black;
}
</style>
<!-- mermaid.js --><script type='module'>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.init(undefined,document.querySelectorAll(".mermaid"));
</script>

<script>
window.MathJax = {
  startup: {
    ready: () => {MathJax.startup.defaultReady();}
  }
};
</script>
<script async id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'></script>

  
  
  <link href='tailwind.css?instanceId=e3d2e198-69e5-4eda-8c1b-e381c9c9db03' rel='stylesheet' type='text/css' />

  <style>
    /* Heist error element */
    strong.error {
      color: lightcoral;
      font-size: 90%;
      font-family: monospace;
    }

    /* Callouts */
    div.callout {
      background-color: #f5f5f5;
      padding: 1em 1em 0.5em;
      border-radius: 0.5em;
      margin-bottom: 1em;
    }

    .callout[data-callout="note"] {
      --callout-color: 8, 109, 221;
    }

    .callout[data-callout="info"] {
      --callout-color: 8, 109, 221;
    }

    .callout[data-callout="tip"] {
      --callout-color: 8, 191, 188;
    }

    .callout[data-callout="warning"] {
      --callout-color: 236, 117, 0;
    }

    .callout[data-callout="failure"] {
      --callout-color: 233, 49, 71;
    }

    div.callout {
      background-color: rgba(var(--callout-color), 0.1);
    }

    .callout .callout-title {
      color: rgb(var(--callout-color));
    }

    div.callout-title {
      display: flex;
      align-items: center;
      margin-bottom: 0.5em;
      font-variation-settings: 'wght' 600;
    }

    div.callout-title div.callout-title-inner {
      margin-left: 0.5em;
    }

    a.--ema-toc:not(.toc-item-active) {
      background-color: #ffffff !important;
    }

    /* External link icon */
    a[data-linkicon=""]::after {
      content: ""
    }

    /* missing from tailwind generated css */
    .min-h-5 {
      min-height: 1.25rem;
    }

    a[data-linkicon=none]::after {
      content: ""
    }

    a[data-linkicon="external"] {
      padding-right: 24px;
    }
    a[data-linkicon="external"]::after {
      margin-right: -24px;
      content: url('data:image/svg+xml,\
      <svg xmlns="http://www.w3.org/2000/svg" height="0.7em" viewBox="0 0 20 20"> \
        <g style="stroke:gray;stroke-width:1"> \
          <line x1="5" y1="5" x2="5" y2="14" /> \
          <line x1="14" y1="9" x2="14" y2="14" /> \
          <line x1="5" y1="14" x2="14" y2="14" /> \
          <line x1="5" y1="5" x2="9" y2="5"  /> \
          <line x1="10" y1="2" x2="17" y2="2"  /> \
          <line x1="17" y1="2" x2="17" y2="9" /> \
          <line x1="10" y1="9" x2="17" y2="2" style="stroke-width:1.0" /> \
        </g> \
      </svg>');
    }

    a[data-linkicon="external"][href^="mailto:"]::after {
      content: url('data:image/svg+xml,\
        <svg \
          xmlns="http://www.w3.org/2000/svg" \
          height="0.7em" \
          fill="none" \
          viewBox="0 0 24 24" \
          stroke="gray" \
          stroke-width="2"> \
          <path \
            stroke-linecap="round" \
            stroke-linejoin="round" \
            d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" /> \
        </svg>');
    }
  </style>
  <!-- What goes in this file will appear on near the end of <head>--><link rel='preload' href='_emanote-static/fonts/Work_Sans/WorkSans-VariableFont_wght.ttf' as='font' type='font/ttf' crossorigin />

<style>
  @font-face {
    font-family: 'WorkSans';
    /* FIXME: This ought to be: ${ema:emanoteStaticLayerUrl}/fonts/Work_Sans/WorkSans-VariableFont_wght.ttf */
    src: url(_emanote-static/fonts/Work_Sans/WorkSans-VariableFont_wght.ttf) format("truetype");
    font-display: swap;
  }

  body {
    font-family: 'WorkSans', sans-serif;
    font-variation-settings: 'wght' 350;
  }

  a.mavenLinkBold {
    font-variation-settings: 'wght' 400;
  }

  strong {
    font-variation-settings: 'wght' 500;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  header,
  .header-font {
    font-family: 'WorkSans', sans-serif;
  }

  h1 {
    font-variation-settings: 'wght' 500;
  }

  h2 {
    font-variation-settings: 'wght' 400;
  }

  h3 {
    font-variation-settings: 'wght' 300;
  }
</style>


  
    <style>
      /* For use in sidebar.tpl, as we cannot achieve this in tailwind itself! */
      /* md:min-w-48  */
      @media (min-width: 768px) {
        #sidebar {
          min-width: 12rem;
        }
      }

      /* xl:min-w-64  */
      @media (min-width: 1280px) {
        #sidebar {
          min-width: 16rem;
        }
      }
    </style>

    
      <link rel='stylesheet' href='_emanote-static/inverted-tree.css' />
    
  
  <link rel='stylesheet' href='_emanote-static/stork/flat.css' />
<!-- Custom Stork-search styling for Emanote -->
<style>
  #stork-search-container {
    z-index: 1000;
    background-color: rgb(15 23 42/.8);
  }

  .stork-overflow-hidden-important {
    overflow: hidden !important;
  }
</style>


<script src='_emanote-static/stork/stork.js'></script>

  
    <script id='emanote-stork' data-emanote-base-url='/'>
      window.emanote = {};
      window.emanote.stork = {
        searchShown: false,
        indexIsStale: false,
        toggleSearch: function () {
          window.emanote.stork.refreshIndex();
          document.getElementById('stork-search-container').classList.toggle('hidden');
          window.emanote.stork.searchShown = document.body.classList.toggle('stork-overflow-hidden-important');
          if (window.emanote.stork.searchShown) {
            document.getElementById('stork-search-input').focus();
          }
        },
        clearSearch: function () {
          document.getElementById('stork-search-container').classList.add('hidden');
          document.body.classList.remove('stork-overflow-hidden-important');
          window.emanote.stork.searchShown = false;
        },

        getBaseUrl: function () {
          const baseUrl = document.getElementById("emanote-stork").getAttribute('data-emanote-base-url') || '/';
          return baseUrl;
        },

        registerIndex: function (options) {
          const indexName = 'emanote-search'; // used to match input[data-stork] attribute value
          const indexUrl = window.emanote.stork.getBaseUrl() + '-/stork.st';
          stork.register(
            indexName,
            indexUrl,
            options);
        },

        init: function () {
          if (document.readyState !== 'complete') {
            window.addEventListener('load', function () {
              stork.initialize(window.emanote.stork.getBaseUrl() + '_emanote-static/stork/stork.wasm');
              window.emanote.stork.registerIndex();
            });

            document.addEventListener('keydown', event => {
              if (window.emanote.stork.searchShown && event.key === 'Escape') {
                window.emanote.stork.clearSearch();
                event.preventDefault();
              } else if ((event.key == 'k' || event.key == 'K') && (event.ctrlKey || event.metaKey)) {
                window.emanote.stork.toggleSearch();
                event.preventDefault();
              }
            });
          } else {
            // This section is called during Ema's hot reload.
            // 
            // Mark the current index as stale, and refresh it *only when* the
            // user actually invokes search.
            // 
            // We do not refresh the index *right away*, as that will cause
            // memory leaks in the browser. See
            // https://github.com/srid/emanote/issues/411#issuecomment-1402056235
            console.log("stork: Marking index as stale");
            window.emanote.stork.markIndexAsStale();
          }
        },

        markIndexAsStale: function () {
          window.emanote.stork.indexIsStale = true;
        },

        refreshIndex: function () {
          if (window.emanote.stork.indexIsStale) {
            console.log("stork: Reloading index");
            window.emanote.stork.indexIsStale = false;
            // NOTE: This will leak memory. See the comment above.
            window.emanote.stork.registerIndex({ forceOverwrite: true });
          }
        }

      };

      window.emanote.stork.init();
    </script>
  

</head>

<!-- DoNotFormat -->



<!-- DoNotFormat -->

<body class='bg-gray-400 overflow-y-scroll'>
  
    <div class='lg:container mx-auto mt-2 md:mt-4  '>
      
        <!-- DoNotFormat -->
<!-- DoNotFormat -->

<nav id='uptree' class='flipped tree' style='transform-origin: 50%;'>
  <ul class='root'>
    <li>
      
        <ul>
          
            <li>

  <a href='blog'>
    <div class='text-gray-900 hover:bg-blue-500 hover:text-white cursor-pointer forest-link'>
      Blog
    </div>
  </a>

  
    <ul>
      
        <li>

  <a href=''>
    <div class='text-gray-900 hover:bg-blue-500 hover:text-white cursor-pointer forest-link'>
      Tristan de Cacqueray
    </div>
  </a>

  
</li>
      
    </ul>
  
</li>
          
        </ul>
      
    </li>
  </ul>
</nav>
      

      

      
        <div id='container' class='relative md:shadow-2xl md:mb-8'>
          
  <div class='absolute -top-6 right-1 md:right-0 flex flex-row items-center justify-center'>
    <a title='Search (Ctrl+K)' class='cursor-pointer' onclick='window.emanote.stork.toggleSearch()'>
      <svg xmlns='http://www.w3.org/2000/svg' style='width: 1rem;' class='hover:text-blue-700' f
 fill='none' viewBox='0 0 24 24' stroke='currentColor' stroke-width='2'>
  <path stroke-linecap='round' stroke-linejoin='round' d='M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'></path>
</svg>
    </a>
  </div>

          <!-- Main body column -->
          <div class='flex-1 w-full bg-white'>
  <main class='px-4 py-4'>
    <h1 id='ema-title' class='flex items-end justify-center mb-4 p-3 bg-blue-100 text-5xl font-extrabold text-black rounded'>
  <a class='z-40 tracking-tighter '>
    Introducing the BytesLines iterator
  </a>
</h1>

  <span class='text-sm text-right font-mono text-gray-600 block -mt-9 rounded px-1 mb-7 min-h-5'>
    2022-03-16
  </span>


    
      <div class='md:grid md:gap-4 md:grid-cols-8'>
        <div class='md:col-span-6'>
          <article class='overflow-auto'>
  <!-- What goes in this file will appear on top of note body-->
  






    <blockquote class='py-0.5 px-4 mb-3 italic border-l-4 bg-gray-50 text-gray-600 border-gray-400 quote'>
      
    <p class='mb-3'>
      This post was initially published on the Software Factory blog: <a href='https://www.softwarefactory-project.io/introducing-the-byteslines-iterator.html' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>https://www.softwarefactory-project.io/introducing-the-byteslines-iterator.html</a>
    </p>
  
    </blockquote>
  
    <p class='mb-3'>
      The BytesLines iterator's goal is to provide an API for processing logs line by line. It processes logs by:
    </p>
  
    <ul class='my-3 ml-6 space-y-1 list-disc'>
      
        <li>
          Splitting sub line to treat cmd output embedded as a long oneliner.
        </li>
      
        <li>
          Working with Read objects, such as file decompressors or network endpoints.
        </li>
      
        <li>
          Using zero copy slices to optimize memory usage.
        </li>
      
        <li>
          Limiting line length to prevent overflow of invalid data.
        </li>
      
    </ul>
  
    <p class='mb-3'>
      This blog post presents:
    </p>
  
    <ul class='my-3 ml-6 space-y-1 list-disc'>
      
        <li>
          Evaluation criterias to compare different implementations.
        </li>
      
        <li>
          A simple implementation using readline.
        </li>
      
        <li>
          Why iterators can't easily produce pointers.
        </li>
      
        <li>
          A zero copy implementation using the <a href='https://docs.rs/bytes/' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>bytes</a> library.
        </li>
      
    </ul>
  
    <p class='mb-3'>
      This article is part of a blog post series about the latest logreduce improvements using the Rust programing language. Please see the series' earlier articles:
    </p>
  
    <ul class='my-3 ml-6 space-y-1 list-disc'>
      
        <li>
          Part1: <a href='blog/logreduce-rust-part1' class='text-blue-600 mavenLinkBold hover:underline' data-wikilink-type='WikiLinkNormal'>Improving logreduce with Rust</a>
        </li>
      
        <li>
          Part2: <a href='blog/logreduce-rust-part2' class='text-blue-600 mavenLinkBold hover:underline' data-wikilink-type='WikiLinkNormal'>Implementing logreduce nearest neighbors model in Rust</a>
        </li>
      
    </ul>
  
    <h2 id='evaluation-criterias' class='group mt-6 mb-4 font-bold text-gray-700 text-4xl'>
      
  Evaluation criterias
  
  <a href='blog/logreduce-rust-part3#evaluation-criterias' class='--ema-anchor'>
    <span class='hover:text-blue-400 group-hover:visible invisible cursor-pointer text-sm align-middle' aria-label='Copy link'><svg class='inline w-4' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
        <path d='M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71'></path>
        <path d='M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71'></path>
      </svg></span>
  </a>


    </h2>
  
    <p class='mb-3'>
      I evaluate the execution time and memory usage to process a 91MB file. Performances are measured with:
    </p>
  
    <ul class='my-3 ml-6 space-y-1 list-disc'>
      
        <li>
          <span class='title-ref'>/bin/time -v</span> to measure the maximum memory usage.
        </li>
      
        <li>
          <span class='title-ref'>valgrind</span> to collect heap usage.
        </li>
      
    </ul>
  
    <p class='mb-3'>
      For example, <span class='title-ref'>grep</span> performance is:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='text language-text'>$ /bin/time --format "Run time: %e sec, Max RSS: %M KB" grep anomaly &lt; test.txt
Run time: 0.05 sec, Max RSS: 2380 KB

$ valgrind grep "anomaly" &lt; test.txt |& grep "heap usage"
total heap usage: 305 allocs, 265 frees, 146,413 bytes allocated</code></pre></div>
    <p class='mb-3'>
      Grep takes about 50 msec and it needs a bit more than 2MB of memory to do its job. Valgrind shows a reasonable heap usage, confirming that grep is well optimized.
    </p>
  
    <p class='mb-3'>
      The next sections present different implementations for the BytesLines iterator.
    </p>
  
    <h2 id='readline-iterator' class='group mt-6 mb-4 font-bold text-gray-700 text-4xl'>
      
  Readline iterator
  
  <a href='blog/logreduce-rust-part3#readline-iterator' class='--ema-anchor'>
    <span class='hover:text-blue-400 group-hover:visible invisible cursor-pointer text-sm align-middle' aria-label='Copy link'><svg class='inline w-4' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
        <path d='M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71'></path>
        <path d='M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71'></path>
      </svg></span>
  </a>


    </h2>
  
    <p class='mb-3'>
      One of the main goals is to avoid reading the whole file at once. Instead, the lines are loaded one at a time using readline. Here is a basic implementation in Python:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='python language-python'>def logfile_iterator(reader):
    line_number = 0
    while True:
        line = reader.readline()
        if not line:
            break
        line = line.rstrip()
        line_number += 1
        for subline in line.split("\\n"):
            yield (subline, line_number)</code></pre></div>
    <p class='mb-3'>
      And here is an equivalent implementation in Rust:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='rust language-rust'>/// A struct to hold the state of the iterator.
pub struct BufLines&lt;R: Read&gt; {
    reader: BufReader&lt;R&gt;,
    buffer: String,
    line_number: usize,
}

impl&lt;R: Read&gt; Iterator for BufLines&lt;R&gt; {
    type Item = Result&lt;(String, usize)&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.buffer.is_empty() {
            self.read_line()
        } else {
            Some(Ok(self.get_line()))
        }
    }
}</code></pre></div>
    <p class='mb-3'>
      Notice that Rust doesn't yet have a special keyword to <em>yield</em> a value. We need to maintain the context in a structure that is passed each time the <em>next</em> method is called. Here are the two functions of this iterator:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='rust language-rust'>// Read a new line and call get_line
fn read_line(&amp;mut self) -&gt; Option&lt;Result&lt;(String, usize)&gt;&gt; {
    match self.reader.read_line(&amp;mut self.buffer) {
        Ok(n) if n &gt; 0 =&gt; {
            // The read succeeded
            self.buffer = self.buffer.trim_end().to_owned();
            Some(Ok(self.get_line()))
        }
        Ok(_) =&gt; None,
        Err(e) =&gt; Some(Err(e)),
    }
}

// Return the first sub line found in the buffer.
fn get_line(&amp;mut self) -&gt; (String, usize) {
    let line = if let Some((sub_line, rest)) = self.buffer.split_once("\\n") {
        let sub_line = sub_line.clone();
        self.buffer = rest.to_owned();
        sub_line
    } else {
        self.line_number += 1;
        let line = self.buffer.clone();
        self.buffer.clear();
        line
    };
    (line, self.line_number)
}</code></pre></div>
    <p class='mb-3'>
      Both of these implementations are using the same algorithm, by calling the <em>readline()</em> helper before splitting sub line on litteral <em>"\n"</em>.
    </p>
  
    <p class='mb-3'>
      Here are their performance characteristics using <em>python3-3.10.2-1.fc35.x86_64</em> and <em>rustc-1.52.1</em>:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='language-none'>+--------------+--------+---------+---------+---------------+--------+
| Im           | Max    | Allocs  | Frees   | Bytes         | Run    |
| plementation | RSS    |         |         | allocated     | time   |
+==============+========+=========+=========+===============+========+
| readline.py  | &gt; 7420 | 1,      | 1,      | &gt; 475,434,838 | 0.33   |
|              | &gt; KB   | 814,409 | 810,434 |               | sec    |
+--------------+--------+---------+---------+---------------+--------+
| readline.rs  | &gt; 2260 | &gt;       | &gt;       | &gt; 285,799,923 | 0.15   |
|              | &gt; KB   | 692,114 | 692,112 |               | sec    |
+--------------+--------+---------+---------+---------------+--------+</code></pre></div>
    <ul class='my-3 ml-6 space-y-1 list-disc'>
      
        <li>
          Both implementations work in constant memory. Using a bigger file does not increase the Max RSS value.
        </li>
      
        <li>
          The high heap allocations numbers indicate that each individual line is duplicated.
        </li>
      
        <li>
          Rust code is more verbose, but it performs more efficiently and safely because it wraps each line with a Result data type to avoid throwing exceptions.
        </li>
      
    </ul>
  
    <p class='mb-3'>
      The next sections present a technique to reduce the number of allocations.
    </p>
  
    <h2 id='iterator-and-item-lifetime' class='group mt-6 mb-4 font-bold text-gray-700 text-4xl'>
      
  Iterator and item lifetime
  
  <a href='blog/logreduce-rust-part3#iterator-and-item-lifetime' class='--ema-anchor'>
    <span class='hover:text-blue-400 group-hover:visible invisible cursor-pointer text-sm align-middle' aria-label='Copy link'><svg class='inline w-4' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
        <path d='M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71'></path>
        <path d='M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71'></path>
      </svg></span>
  </a>


    </h2>
  
    <p class='mb-3'>
      Rust provides facilities for manual memory management, thus it should be possible to avoid the individual line allocation. The line is already present in the iterator internal structure, and instead of cloning a new <em>String</em> I would like to return a <em>&amp;str</em> reference.
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='rust language-rust'>impl&lt;R: Read&gt; Iterator for BufLines&lt;R&gt; {
   type Item = Result&lt;&amp;str&gt;;
}</code></pre></div>
    <p class='mb-3'>
      … but this does not compile because of this error:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='text language-text'>error[E0106]: missing lifetime specifier
  --&gt; readline.rs:17:24
   |
17 |     type Item = Result&lt;&amp;str&gt;;
   |                        ^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
17 |     type Item&lt;'a&gt; = Result&lt;&'a str&gt;;
   |              ^^^^          ^^^</code></pre></div>
    <p class='mb-3'>
      Indeed, the <em>&amp;str</em> reference needs a lifetime parameter to match the owner of the underlying memory. This lifetime parameter is here to ensure the reference is valid as long as the underlying memory is owned. Unfortunately, adding the suggested fix does not work:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='rust language-rust'>impl&lt;R: Read&gt; Iterator for BufLines&lt;R&gt; {
    type Item&lt;'a&gt; = Result&lt;&'a str&gt;;
}</code></pre></div>
    <p class='mb-3'>
      … the compilation still fails because of this new error:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='text language-text'>error[E0658]: generic associated types are unstable
  --&gt; readline.rs:17:5
   |
17 |     type Item&lt;'a&gt; = Result&lt;&'a str&gt;;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: see issue #44265 &lt;https://github.com/rust-lang/rust/issues/44265&gt; for more information</code></pre></div>
    <p class='mb-3'>
      The Rust type system is presently not expressive enough to implement such an iterator. You can read more about this limitation in this article: <a href='http://lukaskalbertodt.github.io/2018/08/03/solving-the-generalized-streaming-iterator-problem-without-gats.html' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>Solving the Generalized Streaming Iterator Problem without GATs</a>.
    </p>
  
    <p class='mb-3'>
      Even then, it is unclear how the users of this iterator would be able to keep that reference after the iteration. This is a requirement for logreduce's reports to include the surrounding anomalies' context.
    </p>
  
    <p class='mb-3'>
      The next section presents an alternative solution using the <a href='https://docs.rs/bytes/' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>bytes</a> library.
    </p>
  
    <h2 id='byteslines-iterator' class='group mt-6 mb-4 font-bold text-gray-700 text-4xl'>
      
  BytesLines iterator
  
  <a href='blog/logreduce-rust-part3#byteslines-iterator' class='--ema-anchor'>
    <span class='hover:text-blue-400 group-hover:visible invisible cursor-pointer text-sm align-middle' aria-label='Copy link'><svg class='inline w-4' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
        <path d='M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71'></path>
        <path d='M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71'></path>
      </svg></span>
  </a>


    </h2>
  
    <p class='mb-3'>
      The <a href='https://docs.rs/bytes/' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>bytes</a> library provides a data type which bundles the reference with the underlying buffer using a reference counter. You can read more about its implementation in the <a href='https://docs.rs/bytes/latest/bytes/struct.Bytes.html#memory-layout' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>Bytes memory layout</a> documentation.
    </p>
  
    <p class='mb-3'>
      This lets us return the line location without doing any memory copy, at the cost of a slight overhead, to keep track of the size and pointer's owners. Here is how the BytesLines iterator is defined:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='rust language-rust'>/// The BytesLines struct holds a single buffer
pub struct BytesLines&lt;R: Read&gt; {
    reader: R,
    buf: BytesMut,
    line_count: usize,
}

impl&lt;R: Read&gt; Iterator for BytesLines&lt;R&gt; {
    type Item = Result&lt;(Bytes, usize)&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.buf.is_empty() {
            self.read_slice()
        } else {
            self.get_slice()
        }
    }
}</code></pre></div>
    <p class='mb-3'>
      Then, similarly to the previous readline implementation, this iterator uses two main functions:
    </p>
  
    <ul class='my-3 ml-6 space-y-1 list-disc'>
      
        <li>
          <em>read_slice</em> to fill up the buffer.
        </li>
      
        <li>
          <em>get_slice</em> to split the next line.
        </li>
      
    </ul>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='rust language-rust'>// Read a new chunk and call get_slice
fn read_slice(&amp;mut self) -&gt; Option&lt;Result&lt;(Bytes, usize)&gt;&gt; {
    let pos = self.buf.len();
    self.buf.resize(pos + CHUNK_SIZE, 0);
    match self.reader.read(&amp;mut self.buf[pos..]) {
        // We read some data.
        Ok(n) if n &gt; 0 =&gt; {
            self.buf.truncate(pos + n);
            self.get_slice()
        }

        // We reached the end of the reader, this is the end.
        Ok(_) =&gt; None,

        // There was a reading error, we return it.
        Err(e) =&gt; Some(Err(e)),
    }
}

// Find the next line in the buffer
fn get_slice(&amp;mut self) -&gt; Option&lt;Result&lt;(Bytes, usize)&gt;&gt; {
    match self.find_next_line() {
        // We haven't found the end of the line, we need more data.
        None =&gt; {
            // reserve() will attempt to reclaim space in the buffer.
            self.buf.reserve(CHUNK_SIZE);
            self.read_slice()
        }

        // We found the end of the line, we can return it now.
        Some((pos, sep)) =&gt; {
            // split_to() creates a new zero copy reference to the buffer.
            let res = self.buf.split_to(pos).freeze();
            self.buf.advance(sep.len());
            Some(Ok((res, self.line_count)))
        }
    }
}</code></pre></div>
    <p class='mb-3'>
      By carefully managing this single buffer, the <a href='https://docs.rs/bytes/' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>bytes</a> library takes care of all the references counting and memory allocations. In particular, the <a href='https://docs.rs/bytes/latest/bytes/struct.BytesMut.html#method.reserve' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>reserve</a> function will attempt to reclaim the available space in-place.
    </p>
  
    <p class='mb-3'>
      Here is a sequence diagram for this implementation:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='text language-text'>⭩- the buffer starts here.
[                          ]          &lt; the buffer is empty, we read a chunk.
[aaaaaaaaaaaa\nbbbbb\nccccc]          &lt; there is a line separator.
╰-----------⮡ next slice
             ⭨
[              bbbbb\nccccc]
              ╰----⮡ next slice
                    ⭨
[                     ccccc]          &lt; the line is incomplete.
     ⭩ we reserve more space and move the left-overs at the begining of the buffer.
[ccccc                           ]    &lt; we read another chunk after the left-overs.
[ccccccc\ndddddddddddddd\neeeeeee]
╰------⮡ next slice
        ⭨
[         dddddddddddddd\neeeeeee]
         ╰-------------⮡ next slice
                        ⭨
[                         eeeeeee]    &lt; the line is incomplete.
       ⭩ we reserve more space and move the left-overs at the begining of the buffer.
[eeeeeee                            ] &lt; we read another chunk after the left-overs.
[eeeeeeeee\n                        ] &lt; we reach the end of file.
╰--------⮡ the last slice</code></pre></div>
    <p class='mb-3'>
      Here are the final results:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='language-none'>+--------------+--------+---------+---------+---------------+--------+
| Im           | Max    | Allocs  | Frees   | Bytes         | Run    |
| plementation | RSS    |         |         | allocated     | time   |
+==============+========+=========+=========+===============+========+
| readline.py  | &gt; 7420 | 1,      | 1,      | &gt; 475,434,838 | 0.33   |
|              | &gt; KB   | 814,409 | 810,434 |               | sec    |
+--------------+--------+---------+---------+---------------+--------+
| readline.rs  | &gt; 2260 | &gt;       | &gt;       | &gt; 285,799,923 | 0.15   |
|              | &gt; KB   | 692,114 | 692,112 |               | sec    |
+--------------+--------+---------+---------+---------------+--------+
| b            | &gt; 2068 | &gt; 24    | &gt; 22    | &gt; 265,577     | 0.12   |
| yteslines.rs | &gt; KB   |         |         |               | sec    |
+--------------+--------+---------+---------+---------------+--------+</code></pre></div>
    <p class='mb-3'>
      As you can see, this iterator avoids unnecessary memory copy, and even though it does more work to satisfy the borrow checker, it is still faster.
    </p>
  
    <p class='mb-3'>
      You can find the source code of the benchmarks in the <a href='https://github.com/logreduce/byteslines-demo' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>logreduce/byteslines-demo</a> project, and you can see the complete version which includes a limiter for the line length in the <a href='https://github.com/logreduce/logreduce-rust/blob/main/iterator/src/iterator.rs' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>logreduce-iterator</a> library.
    </p>
  
    <h2 id='conclusion' class='group mt-6 mb-4 font-bold text-gray-700 text-4xl'>
      
  Conclusion
  
  <a href='blog/logreduce-rust-part3#conclusion' class='--ema-anchor'>
    <span class='hover:text-blue-400 group-hover:visible invisible cursor-pointer text-sm align-middle' aria-label='Copy link'><svg class='inline w-4' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
        <path d='M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71'></path>
        <path d='M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71'></path>
      </svg></span>
  </a>


    </h2>
  
    <p class='mb-3'>
      The Rust programming language provides low-level facilities and high-level features such as <a href='https://doc.rust-lang.org/book/ch06-00-enums.html' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>Algebraic Data Types</a> and <a href='https://doc.rust-lang.org/book/ch10-02-traits.html' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>Traits</a>. This lured me into trying to avoid cloning the memory and learning more about Rust's unique type system.
    </p>
  
    <p class='mb-3'>
      Thanks to the <a href='https://docs.rs/bytes/' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>bytes</a> library I was able to efficiently implement this log line iterator. I think it is well worth the effort since this is such a key component for the project, and I hope this is going to pay off when processing many files in parallel.
    </p>
  
    <p class='mb-3'>
      I always welcome feedback, and I would love to be proven wrong. If you would like to contribute, please join the <a href='https://matrix.to/#/#logreduce:matrix.org' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>logreduce:matrix.org</a> chat room.
    </p>
  
    <p class='mb-3'>
      Thank you for reading!
    </p>
  
  <!-- What goes in this file will appear below the note body-->
</article>
        </div>
        <div class='hidden md:block md:col-span-2 md:border-l'>
          <nav id='toc' class='hidden leading-relaxed md:block md:sticky md:top-0 md:max-h-screen md:overflow-y-auto'>
  <div class='text-gray-600 text-sm'>
    <a class='ml-1 cursor-pointer p-0.5' title='Title' id='--ema-title-toc'>Title</a>
    
        <ul class='ml-2'>
          
            <li class='whitespace-nowrap truncate mt-2' title='Evaluation criterias'>
              <a href='blog/logreduce-rust-part3#evaluation-criterias' class='--ema-toc bg-blue-200 rounded-md p-0.5'>
                Evaluation criterias
              </a>
              
        <ul class='ml-2'>
          
        </ul>
      
            </li>
          
            <li class='whitespace-nowrap truncate mt-2' title='Readline iterator'>
              <a href='blog/logreduce-rust-part3#readline-iterator' class='--ema-toc bg-blue-200 rounded-md p-0.5'>
                Readline iterator
              </a>
              
        <ul class='ml-2'>
          
        </ul>
      
            </li>
          
            <li class='whitespace-nowrap truncate mt-2' title='Iterator and item lifetime'>
              <a href='blog/logreduce-rust-part3#iterator-and-item-lifetime' class='--ema-toc bg-blue-200 rounded-md p-0.5'>
                Iterator and item lifetime
              </a>
              
        <ul class='ml-2'>
          
        </ul>
      
            </li>
          
            <li class='whitespace-nowrap truncate mt-2' title='BytesLines iterator'>
              <a href='blog/logreduce-rust-part3#byteslines-iterator' class='--ema-toc bg-blue-200 rounded-md p-0.5'>
                BytesLines iterator
              </a>
              
        <ul class='ml-2'>
          
        </ul>
      
            </li>
          
            <li class='whitespace-nowrap truncate mt-2' title='Conclusion'>
              <a href='blog/logreduce-rust-part3#conclusion' class='--ema-toc bg-blue-200 rounded-md p-0.5'>
                Conclusion
              </a>
              
        <ul class='ml-2'>
          
        </ul>
      
            </li>
          
        </ul>
      
  </div>
  <script>
    // Highlight the TOC, based from https://stackoverflow.com/a/75346369
    // TODO: We should get rid of JavaScript! See https://github.com/srid/emanote/issues/520
    function highlightTOC() {
      // Setup title link
      const titleToc = document.querySelectorAll("nav > div > a#--ema-title-toc");
      if (titleToc.length) {
        titleToc[0].onclick = () => {
          document.querySelectorAll("h1#ema-title")[0].scrollIntoView({ behavior: "smooth"});
          history.pushState("", document.title, window.location.pathname + window.location.search);
        }
      }
      // Grab the toc links
      const links = document.querySelectorAll("ul > li > a.--ema-toc");

      // Find the matching anchors in the document body
      const sections = [];
      links.forEach((link) => {
        let found = {};
        for (section of document.querySelectorAll("a.--ema-anchor")) {
          if (link.href == section.href) {
            found = section;
            break;
          }
        }
        sections.push(found);
      });

      // Current toc link is marked with the following class
      const mark = "toc-item-active";

      // Set window scroll handler to update the toc mark.
      window.onscroll = () => {
        // Remove previous mark
        links.forEach((link) => {
          link.classList.remove(mark);
        });

        // Mark the link of the section that is in view, starting from the end
        let marked = false;
        for (var i = sections.length - 1; i >= 0; i--) {
          if (window.scrollY > sections[i].offsetTop - 20) {
            links[i].classList.add(mark);
            marked = true;
            break;
          }
        }

        // Special case for the first and last section which might not reach the top
        if (!marked && window.scrollY > 0) {
          let i = 0;
          if ((window.innerHeight + Math.round(window.scrollY)) >= document.body.offsetHeight) {
            // We are at the bottom
            i = links.length - 1
          }
          links[i].classList.add(mark);
        }
      };
    }
    highlightTOC();
  </script>
</nav>

        </div>
      </div>
      
    <div class='flex flex-col lg:flex-row lg:space-x-2'>
      
      
  <div class='flex-1 p-4 mt-8 bg-gray-100 rounded'>
    <header class='mb-2 text-xl font-semibold text-gray-500'>Links to this page</header>
    <ul class='space-y-1'>
      
        <li>
          <a class='text-blue-600 mavenLinkBold hover:bg-blue-50' href='blog/logreduce-rust-part4'>
            Completing the first release of logreduce-rust
          </a>
          
            <div class='mb-4 overflow-auto text-sm text-gray-500'>
  
    <div class='pl-2 mt-2 border-l-2 border-blue-200 hover:border-blue-500'>
      <div>Part2: <a href='blog/logreduce-rust-part3' class='text-gray-600 font-bold hover:bg-gray-50' data-wikilink-type='WikiLinkNormal'>Introducing the BytesLines iterator</a></div>
    </div>
  
</div>
          
        </li>
      
    </ul>
  </div>

    </div>
    
  <section class='flex flex-wrap items-end justify-center my-4 space-x-2 space-y-2 font-mono text-sm'>
    
      <!-- FIXME: The use of -/tags is wrong, because we should use routeUrl using Ema's encoder
        Perhaps Emanote should inject tagMetas with urls.
      -->
      <a title='Tag' class='px-1 bg-gray-100 rounded hover:bg-gray-50 hover:text-blue-500' href='-/tags/blog'>
        <!-- DoNotFormat -->
        #blog
        <!-- DoNotFormat -->
      </a>
    
      <!-- FIXME: The use of -/tags is wrong, because we should use routeUrl using Ema's encoder
        Perhaps Emanote should inject tagMetas with urls.
      -->
      <a title='Tag' class='px-1 bg-gray-100 rounded hover:bg-gray-50 hover:text-blue-500' href='-/tags/rust'>
        <!-- DoNotFormat -->
        #rust
        <!-- DoNotFormat -->
      </a>
    
      <!-- FIXME: The use of -/tags is wrong, because we should use routeUrl using Ema's encoder
        Perhaps Emanote should inject tagMetas with urls.
      -->
      <a title='Tag' class='px-1 bg-gray-100 rounded hover:bg-gray-50 hover:text-blue-500' href='-/tags/logreduce'>
        <!-- DoNotFormat -->
        #logreduce
        <!-- DoNotFormat -->
      </a>
    
  </section>
  <div class='flex items-center justify-center mt-2'>
    <a class='text-gray-300 hover:text-blue-600 text-sm' title='Edit this page on GitHub' href='https://github.com/TristanCacqueray/TristanCacqueray.github.io/edit/main/content/blog/logreduce-rust-part3.md'>
      <svg xmlns='http://www.w3.org/2000/svg' class='h-6 w-6' fill='none' viewBox='0 0 24 24' stroke='currentColor'>
        <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z'></path>
      </svg>
    </a>
    <p class='text-sm text-gray-600 mx-2'>
      This work is licensed under a <a class='hover:underline' href='http://creativecommons.org/licenses/by/4.0/'>Creative Commons Attribution 4.0 International License</a>
    </p>
  </div>


    <!-- What goes in this file will at the very end of the main div -->
  </main>
</div>
        </div>
      
      <footer class='flex items-center justify-center mt-2 mb-8 space-x-4 text-center text-gray-800'>
  
  <div>
    <a href='' title='Go to Home page'>
      <svg xmlns='http://www.w3.org/2000/svg' class='w-6 h-6 hover:text-blue-700' fill='none' viewBox='0 0 24 24' stroke='currentColor'>
        <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6'></path>
      </svg>
    </a>
  </div>
  <div>
    <a href='-/all' title='View Index'>
      <svg class='w-6 h-6 hover:text-blue-700' fill='none' stroke='currentColor' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'>
        <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4'>
        </path>
      </svg>
    </a>
  </div>
  <div>
    <a href='-/tags' title='View tags'>
      <svg class='w-6 h-6 hover:text-blue-700' fill='none' stroke='currentColor' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'>
        <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z'>
        </path>
      </svg>
    </a>
  </div>
  <div>
    <a href='https://emanote.srid.ca' target='_blank' title='Generated by Emanote 1.3.17.1'>
      <img class='w-6 h-6 hover:text-blue-700' src='_emanote-static/emanote-logo.svg' />
    </a>
  </div>
</footer>

    </div>
  
  <div id='stork-search-container' class='hidden fixed w-screen h-screen inset-0 backdrop-filter backdrop-blur-sm'>
  <div class='fixed w-screen h-screen inset-0' onclick='window.emanote.stork.toggleSearch()'></div>

  <div class='container mx-auto p-10 mt-10'>
    <div class='stork-wrapper-flat container mx-auto'>
      <input id='stork-search-input' data-stork='emanote-search' class='stork-input' placeholder='Search (Ctrl+K) ...' />
      <div data-stork='emanote-search-output' class='stork-output'></div>
    </div>
  </div>
</div>
  
    
  
</body>

</html>

